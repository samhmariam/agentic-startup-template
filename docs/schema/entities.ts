/**
 * docs/schema/entities.ts
 *
 * Single source of truth for all domain entities.
 * These Zod schemas are used by:
 *   - Runtime validation (guardrails/schema-validator.ts)
 *   - Agent input/output typing
 *   - RAG context seeding (this file is indexed with highest priority)
 *
 * SCHEMA EVOLUTION CONVENTION
 * ─────────────────────────────
 * 1. Always add new fields as `.optional()` first.
 * 2. Never rename a field — add the new name and mark the old as `.optional()`.
 * 3. Breaking changes require an ADR in docs/decisions/.
 * 4. After each change, the Context Engineer re-indexes this file by running `pnpm seed`.
 */

import { z } from "zod";

// ── Primitives ────────────────────────────────────────────────────────────────

export const ISODateSchema = z.string().datetime({ offset: true });

export const SeveritySchema = z.enum(["critical", "high", "medium", "low", "info"]);
export type Severity = z.infer<typeof SeveritySchema>;

// ── Memory / RAG ──────────────────────────────────────────────────────────────

/**
 * A unit of knowledge stored in and retrieved from the vector store.
 */
export const DocumentSchema = z.object({
  /** Stable, collision-resistant ID — typically a content hash or file:line ref */
  id: z.string().min(1),
  /** The raw text content that was embedded */
  content: z.string().min(1),
  /** Arbitrary metadata stored alongside the embedding for filtering */
  metadata: z.record(z.string(), z.unknown()).default({}),
  /** The Chroma collection this document lives in */
  collection: z.string().min(1).default("default"),
  /** UTC ISO-8601 timestamp of last upsert */
  indexedAt: ISODateSchema.optional(),
});
export type Document = z.infer<typeof DocumentSchema>;

/**
 * A curated "Golden Example" — the highest-priority documents in the RAG.
 * Nominated by the Vibe Engineer or Context Engineer.
 */
export const GoldenExampleSchema = DocumentSchema.extend({
  /** Human-readable title shown in retrieval logs */
  title: z.string().min(1),
  /** Which Pod role nominated this example */
  nominatedBy: z.enum([
    "product-architect",
    "agentic-engineer",
    "context-engineer",
    "security-lead",
    "vibe-engineer",
  ]),
  /** Tags for faceted search (e.g., ["tool-definition", "typescript"]) */
  tags: z.array(z.string()).default([]),
});
export type GoldenExample = z.infer<typeof GoldenExampleSchema>;

// ── Flywheel Stage Artifacts ──────────────────────────────────────────────────

/**
 * Stage 1 → Stage 2 handoff: a structured technical specification.
 * Generated by the Planning Agent (product-architect role).
 */
export const TechSpecSchema = z.object({
  id: z.string().min(1),
  title: z.string().min(1),
  /** Plain-English feature brief from which this spec was synthesised */
  brief: z.string().min(1),
  /** Ordered list of acceptance criteria */
  acceptanceCriteria: z.array(z.string()).min(1),
  /** Files or modules expected to be created or modified */
  affectedPaths: z.array(z.string()).default([]),
  /** Relevant ADR IDs consulted during planning */
  referencedADRs: z.array(z.string()).default([]),
  /** Free-form notes, edge cases, or architectural concerns */
  notes: z.string().optional(),
  createdAt: ISODateSchema,
});
export type TechSpec = z.infer<typeof TechSpecSchema>;

/**
 * Stage 2 → Stage 3/4 handoff: agent-generated code.
 * Generated by the Executor Agent (agentic-engineer role).
 */
export const CodeArtifactSchema = z.object({
  id: z.string().min(1),
  /** The TechSpec this artifact fulfils */
  specId: z.string().min(1),
  /** Map of relative file path → full file contents */
  files: z.record(z.string(), z.string()),
  /** Brief description of what was generated */
  summary: z.string().min(1),
  /** Shell commands to verify the artifact (e.g. ["npm run typecheck", "npm run test:unit"]) */
  verificationSteps: z.array(z.string()).default([]),
  createdAt: ISODateSchema,
});
export type CodeArtifact = z.infer<typeof CodeArtifactSchema>;

/**
 * Stage 3 → Stage 5 handoff: security audit findings.
 * Generated by the Auditor Agent (security-lead role).
 * Findings are also written back to the "vulnerabilities" Chroma collection
 * so future agents learn from them.
 */
export const AuditFindingSchema = z.object({
  severity: SeveritySchema,
  category: z.string().min(1),
  description: z.string().min(1),
  /** File path and line range where the issue was identified, if applicable */
  location: z.string().optional(),
  /** Suggested remediation */
  suggestion: z.string().optional(),
});
export type AuditFinding = z.infer<typeof AuditFindingSchema>;

export const AuditReportSchema = z.object({
  id: z.string().min(1),
  artifactId: z.string().min(1),
  /** true = no critical/high findings, safe to proceed to polish stage */
  passed: z.boolean(),
  findings: z.array(AuditFindingSchema).default([]),
  /** Overall risk narrative */
  summary: z.string().min(1),
  createdAt: ISODateSchema,
});
export type AuditReport = z.infer<typeof AuditReportSchema>;

/**
 * Stage 4 → output: the polished, enterprise-ready artifact.
 * The CodeArtifact schema is reused; this type alias signals provenance.
 */
export type PolishedArtifact = CodeArtifact;

// ── Flywheel Run ──────────────────────────────────────────────────────────────

/**
 * The result of a complete Knowledge Flywheel run (all five stages).
 */
export const FlywheelResultSchema = z.object({
  runId: z.string().min(1),
  brief: z.string().min(1),
  spec: TechSpecSchema,
  artifact: CodeArtifactSchema,
  audit: AuditReportSchema,
  polished: CodeArtifactSchema,
  completedAt: ISODateSchema,
  durationMs: z.number().int().nonnegative(),
  /**
   * Harness Engineering — Trust Gate fields (present only when autoMerge:true).
   * Following schema-evolution convention: new fields are .optional() first.
   */
  autoMerged: z.boolean().optional(),
  logicReviewPassed: z.boolean().optional(),
});
export type FlywheelResult = z.infer<typeof FlywheelResultSchema>;
